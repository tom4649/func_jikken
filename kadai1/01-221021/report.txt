課題01
富張聡祥　05221021

問1
動作例
sum_to:
utop # sum_to 0;;
- : int = 0
utop # sum_to 100;;
- : int = 5050

is_prime:
utop # is_prime 211;;
- : bool = true
utop # is_prime 212;;
- : bool = false

gcd:
utop # gcd 30 30;;
- : int = 30
gcd 20 30;;
- : int = 10

問2
動作例
twice:
utop # twice (fun x -> 2*x) 3;;
- : int = 12
utop # twice (fun x -> x*x) 3;;
- : int = 81

repeat:
utop # repeat (fun x -> 2*x) 4 3;;
- : int = 48

問3
動作例
sum_to_fix:
utop # sum_to_fix 0;;
- : int = 0
utop # sum_to_fix 100;;
- : int = 5050

is_prime_fix:
utop # is_prime_fix 211;;
- : bool = true
utop # is_prime_fix 212;;
- : bool = false

gcd_fix:
utop # gcd_fix 30 30;;
- : int = 30
utop # gcd_fix 20 30;;
- : int = 10

考察
関数fixは、関数fとその引数xを受け取って、関数fの不動点となるような関数
(つまり、f(fix f) = fix f)に引数をあたえたものを返す関数であると解釈できる。
これを利用して、求めたい再帰関数が不動点となるような関数**_genを定義し、
fixにこの関数**_gen(とその引数)を与えることによって、
再帰関数を使わずに問1の関数を実装した。
なお、引数が2つある関数については、fixによって与えられる引数が１つだけなので、
pair型を利用して引数を１つにまとめることで実装した。

問4
動作例
fold_right:
utop # fold_right (fun x y -> x*x*y*y) [1;2;3] 1;;
- : int = 104976

fold_left:
utop # fold_left (fun x y -> x*x*y*y) 1 [1;2;3];;
- : int = 144

考察
fold_right,fold_leftともに再帰関数を利用することで問題なく実装できた。
fold_leftが末尾再帰になっている一方でfold_rightはそうではないので、fold_leftの方がメモリの消費が少なくて済むと考えられる。

問5
動作例
append:
utop # append [1;2;3] [4;5;6;7;8];;
- : int list = [1; 2; 3; 4; 5; 6; 7; 8]
utop # append[0;1;2;3;4;5;6;7;8;9;0;1;2;3;4;5;6;7;8;9;0;1;2;3;4;5;6;7;8;9;0;1;2;3;4;5;6;7;8;9] [0;1;2;3;4;5;6;7;8;9];;
- : int list =
[0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 0; 1;
 2; 3; 4; 5; 6; 7; 8; 9; 0; 1; 2; 3; 4; 5; 6; 7; 8; 9]

filter:
utop # filter (fun x -> x > 5) [1;7;2;5;6;8;10];;*);;
- : int list = [7; 6; 8; 10]
utop # filter (fun x -> x > 5) [0;1;2;3;4;5;6;7;8;9;0;1;2;3;4;5;6;7;8;9;0;1;2;3;4;5;6;7;8;9;0;1;2;3;4;5;6;7;8;9;0;1;2;3;4;5;6;7;8;9];;*);;
- : int list =
[6; 7; 8; 9; 6; 7; 8; 9; 6; 7; 8; 9; 6; 7; 8; 9; 6; 7; 8; 9]

考察
いずれの関数も再帰関数を用いることで実装できた。
ただ末尾再帰でないために途中の計算結果を保持しておく必要があるのでメモリの消費が大きいのではないかと考えられる。
動作例にあるような長さでは問題なく動作した。

問6
動作例
append_right:
utop # append_right[0;1;2;3;4;5;6;7;8;9;0;1;2;3;4;5;6;7;8;9;0;1;2;3;4;5;6;7;8;9;0;1;2;3;4;5;6;7;8;9] [0;1;2;3;4;5;6;7;8;9];;
- : int list =
[0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 0; 1; 2; 3; 4; 5;
 6; 7; 8; 9; 0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 0; 1;
 2; 3; 4; 5; 6; 7; 8; 9; 0; 1; 2; 3; 4; 5; 6; 7;
 8; 9]

filter_right:
utop # filter_right (fun x -> x > 5) [0;1;2;3;4;5;6;7;8;9;0;1;2;3;4;5;6;7;8;9;0;1;2;3;4;5;6;7;8;9;0;1;2;3;4;5;6;7;8;9;0;1;2;3;4;5;6;7;8;9];;*);;
- : int list =
[6; 7; 8; 9; 6; 7; 8; 9; 6; 7; 8; 9; 6; 7; 8; 9;
 6; 7; 8; 9]

append_left:
utop # append_left[0;1;2;3;4;5;6;7;8;9;0;1;2;3;4;5;6;7;8;9;0;1;2;3;4;5;6;7;8;9;0;1;2;3;4;5;6;7;8;9] [0;1;2;3;4;5;6;7;8;9];;
- : int list =
[0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 0; 1; 2; 3; 4; 5;
 6; 7; 8; 9; 0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 0; 1;
 2; 3; 4; 5; 6; 7; 8; 9; 0; 1; 2; 3; 4; 5; 6; 7;
 8; 9]

filter_left:
utop # filter_left (fun x -> x > 5) [0;1;2;3;4;5;6;7;8;9;0;1;2;3;4;5;6;7;8;9;0;1;2;3;4;5;6;7;8;9;0;1;2;3;4;5;6;7;8;9;0;1;2;3;4;5;6;7;8;9];;*);;
- : int list =
[6; 7; 8; 9; 6; 7; 8; 9; 6; 7; 8; 9; 6; 7; 8; 9;
 6; 7; 8; 9]

考察
fold_left,fold_rightを用いて実装した関数は、調べた範囲では実行時間には差が見られなかった。
しかし、fold_rightはfold_rightと異なり末尾再帰になっていないので、fold_leftを用いて実装した関数の方がメモリの消費や実行時間が少なくて済むと考えられる。
実装のしやすさの点では、fold_rightを用いた関数の方がfold_leftを用いた関数よりも実装しやすいように感じた。
これはfold_rightがリストの後ろの方,fold_leftがリストの前の方から処理をする関数という違いのためである。
なお、２つの引数を受け取るfilterの実装の際には、fold_left、fold_rightが関数に割り当てる引数を一つしか受け取ることができないので、
filterが受け取る引数を組にしてfold_left、fold_rightに渡すことで実装した。

問7
実行例
utop # perm[1];;
- : int list list = [[1]]
utop # perm[1;2;3;4];;
- : int list list =
[[1; 2; 3; 4]; [2; 1; 3; 4]; [2; 3; 1; 4]; [2; 3; 4; 1]; [1; 3; 2; 4];
 [3; 1; 2; 4]; [3; 2; 1; 4]; [3; 2; 4; 1]; [1; 3; 4; 2]; [3; 1; 4; 2];
 [3; 4; 1; 2]; [3; 4; 2; 1]; [1; 2; 4; 3]; [2; 1; 4; 3]; [2; 4; 1; 3];
 [2; 4; 3; 1]; [1; 4; 2; 3]; [4; 1; 2; 3]; [4; 2; 1; 3]; [4; 2; 3; 1];
 [1; 4; 3; 2]; [4; 1; 3; 2]; [4; 3; 1; 2]; [4; 3; 2; 1]]
utop # perm[1;2;3;4;5;6;7;8;9;10];;
Stack overflow during evaluation (looping recursion?).

考察
関数permの実装を
リストla,lbと要素cを受け取って、リストlaとlbの要素の間にcを挿入したリストを返す関数insert
リストのリストllと要素cを受け取って、llの中の全てのリストに対して、間にcを挿入したリストのリストを返す関数app
を実装することによって実現した。
いずれも再帰関数として実装した。
実行例にあるように、長さ10の配列を与えるとstack overflowが発生した。

発展1
実行例
reverse
utop # reverse [1;2;3;4;5;6;7;8;9;10;11;12;13;14;15];;
- : int list = [15; 14; 13; 12; 11; 10; 9; 8; 7; 6; 5; 4; 3; 2; 1]
utop # reverse [];;
- : 'a list = []

reverse_right:
utop # reverse_right [1;2;3;4;5;6;7;8;9;10;11;12;13;14;15;16;17;18;19;20;21;22;23;24;25;26;27;28;29;30];;
- : int list =
[30; 29; 28; 27; 26; 25;
 24; 23; 22; 21; 20; 19;
 18; 17; 16; 15; 14; 13;
 12; 11; 10; 9; 8; 7; 6;
 5; 4; 3; 2; 1]

考察
reverseを線形時間で実装するために、末尾再帰によってリストを逆順にするreverse_subを定義した。
この関数はリストlaとresを受け取って、laの要素を逆順にresの先頭に追加する処理を行う。
laの要素を前から一つずつ順にresに追加していくのでこの関数はlaの長さに対して線形時間で動作する。
したがってこれを利用して実装した関数reverseもリストの長さに対して線形時間で動作する。
fold_rightを用いてreverse_rightを実装するために、関数合成を利用した再帰関数によってfold_rightに渡す関数reverse_fを定義した。
この関数は要素xとリストを受け取ってリストを返す関数gを受けとって、リストを受け取って関数gの適用前にxを前に加える操作を合成した関数を返す。
fold_rightに第一引数としてこの関数reverse_f、第二引数にリストl、第三引数として恒等関数を渡すとリストを受け取ってその要素を逆順に加える関数が得られるので、
これを空リストに適用することで求める関数reverse_rightを実装できた。

発展2
実行例
reverse_left_by_right:
utop # fold_left_by_right (fun x y -> x*x*y*y) 1 [1;2;3];;
- : int = 144

reverse_right_by_left:
utop # fold_right_by_left (fun x y -> x*x*y*y)  [1;2;3]1 ;;
- : int = 104976

考察
発展1のreverse_rightの実装と同様に逆向きに関数を合成することを利用して、reverse_left_by_right,reverse_right_by_leftを実装した。
そのためにfold_right,fold_leftに渡す関数を、関数を返す関数(高階関数)として、関数を逆向きに合成できるようにした。
発展1,2ともにリストに対する操作の順序を逆向きにするためには、高階関数を利用して関数を逆向きに合成することがポイントであるように感じた。
また、求めたい関数はfold_right、fold_rightが返した関数に、引数eを与えることによって得た。

発展3
実行例
utop # let four = fun f x -> f(f(f(f x)));;
val four : ('a -> 'a) -> 'a -> 'a = <fun>
utop # let three = fun f x -> f(f(f x));;
val three : ('a -> 'a) -> 'a -> 'a =
  <fun>
utop # add four three (fun y -> y+1) 0;;
- : int = 7
utop # sub four three (fun y -> y+1) 0;;
- : int = 1
utop # mul four three (fun y -> y+1) 0;;
- : int = 12

レコードを使った実装:
utop # type myint = {var : 'a. ('a->'a) -> 'a -> 'a};;
type myint = {
  var : 'a. ('a -> 'a) -> 'a -> 'a;
}
utop #    let four' = {var = fun f x -> f(f(f(f x)))};;
val four' : myint = {var = <fun>}
utop #    let three' = {var = fun f x -> f(f(f x))};;
utop #    sub' four' three' (fun y -> y+1) 0;;
- : int = 1

考察
問題には明記されていなかったが、この問はchurch encodingによる自然数の表現において、演算を行う関数を実装する問である。
小林教授による駒場の「計算の理論」の講義の授業スライドを参考にすることで、addとsubはchurch encodingの本来の操作によって実装することができた。
しかし、関数subを同様に実装しようとすると型推論の際にエラーが生じてしまい、うまく実装できなかった。
一つ前の自然数を返す関数predを実装して
pred(pred three)(fun y->y+1)0;;とすると1が正しく得られるが、
((fun f x -> f (f x)) pred three)(fun y->y+1)0;;とすると型が合わずにエラーが生じた。
調べて見ると、この原因はOCamlが値多相という性質を持った言語であることに起因するようであるがあまり理解できていない。
結局church encodingを整数に直して計算し、もう一度church encodingに直すという方針によって関数sub自体は実装できた。
また、レコードを使うことで、多相型を許す関数を実装することができ、それによってもsub'を実装することができたが、この方針では自分で型を指定しており、課題の指示と少しずれている。
完全な形でこのエラーを解消することには至らなかったので今後の課題としたい。

(参考:https://www.fos.kuis.kyoto-u.ac.jp/~igarashi/class/isle4-02w/mltext/ocaml005.html)

